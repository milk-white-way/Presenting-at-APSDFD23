\documentclass[\string~/GitHub/sthlmNordBeamerTheme/sthlmNordLightDemo.tex]{subfiles}

\begin{document}
%   FRAME START   -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
\begin{frame}[c, fragile, allowframebreaks]{Completed Module 1}{MultiFab Tutorial}
    \begin{exampleblock}{MultiFab Tutorial}
        This tutorial focus on one of the most important class of AMReX, the MultiFab. The goals are:
            \begin{itemize}
                \item \cDarkBlack{Create a MultiFab.}
                \item \cDarkBlack{Write data to a MultiFab.}
                \item \cDarkBlack{Plot data from a MultiFab.}
            \end{itemize}
    \end{exampleblock}

    \remarks What has been learned:
        \begin{itemize}
		\item  Defining a MultiFab \hlOrange{mf (ba, dm, ncomp, ngrow)} takes 4 inputs: 
                \begin{itemize}
                    \item \texttt{\hlAquaBlue{ba}}: a BoxArray;
                    \item \texttt{\hlLightBlue{dm}}: a Distribution Mapping;
                    \item \texttt{\hlBlue{ncomp}}: the number of components to be stored in the MultiFab; and
                    \item \texttt{\hlDarkBlue{ngrow}}: the number of layers of ghost cells.
                \end{itemize}
		\item  Accessing data in the MultiFab by loop structure: combine \hlRed{MFIter} and \hl{ParallelFor}:
                \begin{center}
                    \begin{minted}[linenos, breaklines, fontfamily=helvetica, fontsize=\footnotesize]{C++}
                        for(amrex::MFIter mfi(mf); mfi.isValid(); ++mfi){
                    
                            const amrex::Box& bx = mfi.validbox();
                            const amrex::Array4<amrex::Real>& mf_array = mf.array(mfi);

                            amrex::ParallelFor(bx, [=] AMREX_GPU_DEVICE(int i, int j, int k){

                            amrex::Real x = (i+0.5) * dx[0];
                            amrex::Real y = (j+0.5) * dx[1];
                            amrex::Real z = (k+0.5) * dx[2];
                            amrex::Real rsquared = ((x-0.5)*(x-0.5) + (y-0.5)*(y-0.5) + (z-0.5)*(z-0.5))/0.01;
                            mf_array(i,j,k) = 1.0 + std::exp(-rsquared);

                            });
                        }
                    \end{minted}
                \end{center}
                
		\item  AMReX allows for selection of either 2D or 3D option at compile time using \hlGreen{AMREX\_SPACEDIM}:
                \begin{center}
                    \begin{minted}[linenos, breaklines, fontfamily=helvetica, fontsize=\scriptsize]{C++}
                            for (MFIter mfi(phi_old); mfi.isValid(); ++mfi)
                            {
                                const Box& bx = mfi.validbox();
                                const Array4<Real>& phiOld = phi_old.array(mfi);
                                amrex::ParallelFor(bx, [=] AMREX_GPU_DEVICE(int i, int j, int k)
                                {
                                    Real x = (i+0.5) * dx[0];
                                    Real y = (j+0.5) * dx[1];
                            #if (AMREX_SPACEDIM == 2)
                                    Real rsquared = ((x-0.5)*(x-0.5)+(y-0.5)*(y-0.5))/0.01;
                            #elif (AMREX_SPACEDIM == 3)
                                    Real z= (k+0.5) * dx[2];
                                    Real rsquared = ((x-0.5)*(x-0.5)+(y-0.5)*(y-0.5)+(z-0.5)*(z-0.5))/0.01;
                            #endif
                                    phiOld(i,j,k) = 1. + std::exp(-rsquared);
                                });
                            }
                    \end{minted}
                \end{center}
                
		\item A newer approach calls for explicit indices and utilize \hlPurple{ParallelFor} only:
                \begin{center}
                    \begin{minted}[linenos, breaklines, fontfamily=helvetica, fontsize=\footnotesize]{C++}
                            const& amrex::MultiArray4 mf_arrs = mf.arrays();
                            const amrex::IntVect ngs(ngrow);

                            amrex::ParallelFor(
                            {
                                mf, ngs, [=] AMREX_GPU_DEVICE(int nbx, int i, int j, int k) noexcept 
                                {
                                    amrex::Real x = (i+0.5) * dx[0];
                                    amrex::Real y = (j+0.5) * dx[1];
                                    amrex::Real z = (k+0.5) * dx[2];
                                    amrex::Real rsquared = ((x-0.5)*(x-0.5)+(y-0.5)*(y-0.5)+(z-0.5)*(z-0.5))/0.01;
                                    mf_arrs[nbx](i,j,k) = 1. + std::exp(-rsquared);
                                }
                            });
                    \end{minted}
                \end{center}
	\end{itemize}
 
\end{frame}
%   FRAME END   --==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=  
\end{document}