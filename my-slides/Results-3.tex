\documentclass[\string~/GitHub/sthlmNordBeamerTheme/sthlmNordLightDemo.tex]{subfiles}

\begin{document}
%   FRAME START   -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
\begin{frame}[c, fragile, allowframebreaks]{Completed Module 3}{Heat Equation Series}
    \begin{itemize}
        \item \hlRed{Heat\_Equation\_EX0\_C}: Most simple method.
        \item \hlOrange{Heat\_Equation\_EX1\_C}: Custom kernel for the calculation of Fluxes.
        \item \hl{Heat\_Equation\_EX2\_C}: Something.
        \item \hlPurple{Heat\_Equation\_EX3\_C}: Linear Solver.
    \end{itemize}

    \remarks Hello World!

    \framebreak
    \prob The Example 3 of Heat Equation Series has a Initialization kernel in Fortran. Write a C equivalent Initialization kernel for this example.

    \framebreak
    \soln The Initialization function (called \hlDarkBlue{init\_phi(i, j, k, phi, dx, prob\_lo}) can be defined in a custom kernel (called \hlBlue{mykernel.H} as follow:
        \begin{center}
            \begin{minted}[linenos, breaklines, fontfamily=helvetica, fontsize=\scriptsize]{C++}
                #include <AMReX_FArrayBox.H>
                using namespace amrex;
                AMREX_GPU_DEVICE AMREX_FORCE_INLINE
                void init_phi (int i, int j, int k,
                amrex::Array4<amrex::Real> const& phi,
                GpuArray<amrex::Real,AMREX_SPACEDIM> const& dx,
                GpuArray<amrex::Real,AMREX_SPACEDIM> const& prob_lo)
                {
                    using amrex::Real;;
                    Real x = prob_lo[0] + (i+Real(0.5)) * dx[0];
                    Real y = prob_lo[1] + (j+Real(0.5)) * dx[1];
                #if (AMREX_SPACEDIM > 2)
                    Real z = prob_lo[2] + (k+Real(0.5)) * dx[2];
                    Real r2 = ((x-Real(0.25))*(x-Real(0.25))+(y-Real(0.25))*(y-Real(0.25))+(z-Real(0.25))*(z-Real(0.25)))/Real(0.01);
                #else
                    Real z = Real(0.);
                    Real r2 = ((x-Real(0.25))*(x-Real(0.25))+(y-Real(0.25))*(y-Real(0.25)))/Real(0.01);
                #endif
                phi(i,j,k) = Real(1.) + std::exp(-r2);
                }
            \end{minted}
        \end{center}

        Then a subroutine \hlAquaBlue{init\_phi(phi\_new, geom)} can be created to apply function \hlDarkBlue{init\_phi} at each valid node such that:
        \begin{center}
            \begin{minted}[linenos, breaklines, fontfamily=helvetica, fontsize=\scriptsize]{C++}
                void init_phi(amrex::MultiFab& phi_new, amrex::Geometry const& geom)
                {
                    GpuArray<Real, AMREX_SPACEDIM> dx = geom.CellSizeArray();
                    GpuArray<Real, AMREX_SPACEDIM> prob_lo = geom.ProbLoArray();

                    for (MFIter mfi(phi_new); mfi.isValid(); ++mfi)
                    {
                        const Box& vbx = mfi.validbox();
                        auto const& phiNew = phi_new.array(mfi);
                        amrex::ParallelFor(vbx, [=] AMREX_GPU_DEVICE(int i, int j, int k)
                        {
                            init_phi(i, j, k, phiNew, dx, prob_lo);
                        });
                    }
                }
            \end{minted}
        \end{center}
 
\end{frame}
%   FRAME END   --==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
\end{document}